const修饰函数参数
	防止传入的参数代表的内容在函数体内被改变，但仅对指针和引用有意义。因为如果是按值传递，传给参数的仅仅是实参的副本，即使在函数体内改变了形参，实参也不会得到影响,没有任何实际意义。
	const修饰的函数参数是指针时,代表在函数体内不能修改该指针所指的内容，起到保护作用，在字符串复制的函数中保证不修改源字符串的情况下，实现字符串的复制。而且const指针可以接收非const和const指针，而非const指针只能接收非const指针。
	const修饰引用时：如果函数参数为用户自定义的类对象如：void h(A a){...}传递进来的参数a是实参对象的副本，要调用构造函数来构造这个副本，而且函数结束后要调用析构函数来释放这个副本，在空间和时间上都造成了浪费，所以函数参数为类对象的情况，推荐用引用。但按引用传递，造成了安全隐患，通过函数参数的引用可以修改实参的内部数据成员，所以用const来保护实参。void h(const A & a){...}

const修饰函数返回值
	也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是使得函数调用表达式不能作为左值。

#include <iostream>  
using namespace std;  
  
class A {
private:
	int i;
public:
	A(){i=0;}
	int & get(){
		return i;
	}
};

void main(){
	A a;
	cout<<a.get()<<endl; //数据成员值为0
	a.get()=1; //尝试修改a对象的数据成员为1，而且是用函数调用表达式作为左值。
	cout<<a.get()<<endl; //数据成员真的被改为1了，返回指针的情况也可以修改成员i的值，所以为了安全起见最好在返回值加上const，使得函数调用表达式不能作为左值
}